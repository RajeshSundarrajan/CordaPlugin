plugins {
    id 'base'
}

// here we define the tasks which will build the plugins in the subprojects
subprojects { subProject ->
    // we have to apply the gradle jvm plugin, because it provides the jar and build tasks
    apply plugin: 'org.jetbrains.kotlin.jvm'

    // for the jar task we have to set the plugin properties, so they can be written to the manifest
    def pluginJar = tasks.named('jar', Jar)  {
        manifest {
            attributes['Plugin-Class'] = subProject.pluginClass
            attributes['Plugin-Id'] = subProject.pluginId
            attributes['Plugin-Version'] = archiveVersion
            attributes['Plugin-Provider'] = subProject.pluginProvider
            attributes['Plugin-Description'] = subProject.pluginDescription
        }
    }


    // the plugin task will put the files into a zip file
    def plugin = tasks.register('plugin', Jar) {
        archiveBaseName = "plugin-${subProject.pluginId}"

        // first taking the classes generated by the jar task
        into('classes') {
            with pluginJar.get()
        }
        // and then we also need to include any libraries that are needed by the plugin
        dependsOn configurations.runtimeClasspath.buildDependencies
        into('lib') {
            from configurations.runtimeClasspath.filter { it.name.endsWith('jar')} 
        }
        archiveExtension = 'zip'
    }

    // the assemblePlugin will copy the zip file into the common plugins directory
    tasks.register('assemblePlugin', Copy) {
        from plugin
        into pluginsDir
    }


    artifacts {
        archives plugin
    }
}

def assemblePlugins = tasks.register('assemblePlugins', Copy) {
    dependsOn(subprojects.collect { it.tasks.named('assemblePlugin') })
}

tasks.named('assemble'){
    dependsOn assemblePlugins
}
